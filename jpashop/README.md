# 엔티티 매핑
 	- 객체와 테이블 매핑
 	- 데이터베이스 스키마 자동생성
 	- 필드와 컬럼 매핑
 	- 기본 키 매핑
 	
# 연관관계 매핑 기초
	- 객체와 테이블 연관관계의 차이를 이해
	- 객체의 참조와 테이블의 외래 키를 매핑
	- 방향 : 단방향, 양방향
	- 다중성 : 다대일, 일대다, 일대일, 다대다
	- 연관관계의 주인 : 객체 양방향 연관관계는 관리가 필요
	
# 양방향 매핑 규칙
	- 객체의 두 관계중 하나를 연관관계의 주인으로 지정
	- 연관관계의 주인만이 외래 키를 관리(등록, 수정)
	- 주인이 아닌쪽은 읽기만 가능
	- 주인은 mappedBy 속성 사용 x
	- 주인이 아니면 mappedBy 속성으로 주인 지정
	- 외래 키가 있는 곳을 주인으로 정해라

# N:M 관계는 1:N, N:1
	- 테이블의 N:M 관계는 중간 테이블을 이용하여 1:N, N:1
	- 실전에서는 중간 테이블이 단순하지 않아 @ManyToMany 사용 x
	- @ManyToMany는 제약: 필드 추가 x, 엔티티 테이블 불일치

# 주요 어노테이션
	- @Inheritance(strategy=InheritanceType.XXX) 
		• JOINED: 조인 전략 
		• SINGLE_TABLE: 단일 테이블 전략 
		• TABLE_PER_CLASS: 구현 클래스마다 테이블 전략 
	• @DiscriminatorColumn(name=“DTYPE”) 
	• @DiscriminatorValue(“XXX”) 테이블에 들어오는 자식 엔티티 명을 변경 할 수 있다.

# @MappedSuperclass
	- 상속관계 매핑 x
	- 엔티티 x, 테이블과 매핑 x
	- 부모 클래스를 상속 받는 자식 클래스에 매핑 정보만 제공
	- 조회, 검색 불가(em.find())
	- 직접 생성해서 사용할 일이 없으므로 추상 클래스 권장
	- 테이블과 관계 없고, 단순히 엔티티가 공통으로 사용하는 매핑 정보를 모으는 역할
	- 주로 등록일, 수정일, 등록자, 수정자 같은 전체 엔티티에서 공통으로 적용하는 정보를 모을 때 사용
	- @Entity 클래스는 엔티티나 @MappedSuperclass로 지정한 클래스만 상속 가능
	
# 프록시
	- em.find() : 데이터베이스를 통해서 실제 엔티티 객체 조회
	- em.getReference(): 데이터베이스 조회를 미루는 가짜(프록시)엔티티 객체 조회
	- 실제 클래스를 상속 받아서 만들어짐
	- 실제 클래스와 겉 모앙이 같다.
	프록시 특징
		- 프록시 객체는 처음 사용할 때 한 번만 초기화
		- 프록시 객체는 원본 엔티티를 상속받음, 따라서 타입 체크시 주의 바람 ( == 비교 실패, 대신 instance of 사용)
		- 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference()를 호출해도 실제 엔티티 반환
		- 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시를 초기화 시 문제 발생 (중요!!!)
		- 강제 초기화 hibenate.initialize(refMember)
	
	
	
	
	
	
	
	
	
	
	
	
	
	